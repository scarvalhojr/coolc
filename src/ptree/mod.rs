//! Parse tree structures, which are directly generated by the parser
//! from Cool source code.

mod format;

use self::format::*;
use crate::tokens::{Ident, Span, TokenKind, TypeId};
use ExpressionData::*;

pub struct Program<'a> {
    pub classes: Vec<Class<'a>>,
}

impl<'a> Program<'a> {
    pub fn new(classes: Vec<Class<'a>>) -> Self {
        Self { classes }
    }

    pub fn format(&'a self) -> ProgramFormatter<'a> {
        ProgramFormatter::new(self)
    }
}

#[derive(Debug, PartialEq)]
pub struct Class<'a> {
    pub name: TypeId,
    pub super_class_name: TypeId,
    pub features: Vec<Feature<'a>>,
    pub location: Span<'a>,
}

impl<'a> Class<'a> {
    pub fn new(
        name: TypeId,
        super_class: Option<TypeId>,
        features: Vec<Feature<'a>>,
        location: Span<'a>,
    ) -> Self {
        let super_class_name =
            super_class.unwrap_or_else(|| "Object".to_string());
        Self {
            name,
            super_class_name,
            features,
            location,
        }
    }

    pub fn format(&'a self, indent: usize) -> ClassFormatter<'a> {
        ClassFormatter::new(self, indent)
    }
}

#[derive(Debug, PartialEq)]
pub struct Feature<'a> {
    pub data: FeatureData<'a>,
    pub location: Span<'a>,
}

impl<'a> Feature<'a> {
    pub fn new(data: FeatureData<'a>, location: Span<'a>) -> Self {
        Self { data, location }
    }

    pub fn format(&self, indent: usize) -> FeatureFormatter {
        FeatureFormatter::new(self, indent)
    }
}

#[derive(Debug, PartialEq)]
pub enum FeatureData<'a> {
    Attribute(Ident, TypeId, Option<Expression<'a>>),
    Method(Ident, TypeId, Vec<Formal<'a>>, Expression<'a>),
}

impl FeatureData<'_> {
    pub fn format(&self, indent: usize) -> FeatureDataFormatter {
        FeatureDataFormatter::new(self, indent)
    }
}

#[derive(Debug, PartialEq)]
pub struct Formal<'a> {
    pub name: Ident,
    pub type_id: TypeId,
    pub location: Span<'a>,
}

impl<'a> Formal<'a> {
    pub fn new(name: Ident, type_id: TypeId, location: Span<'a>) -> Self {
        Self {
            name,
            type_id,
            location,
        }
    }

    pub fn format(&self, indent: usize) -> FormalFormatter {
        FormalFormatter::new(self, indent)
    }
}

#[derive(Debug, PartialEq)]
pub struct Expression<'a> {
    pub data: ExpressionData<'a>,
    pub location: Span<'a>,
}

impl<'a> Expression<'a> {
    pub fn new(data: ExpressionData<'a>, location: Span<'a>) -> Self {
        Self { data, location }
    }

    pub fn format(&self, indent: usize) -> ExpressionFormatter {
        ExpressionFormatter::new(self, indent)
    }
}

#[derive(Debug, PartialEq)]
pub enum ExpressionData<'a> {
    Assign(Ident, Box<Expression<'a>>),
    UnaryOperation(UnaryOperator, Box<Expression<'a>>),
    BinaryOperation(BinaryOperator, Box<Expression<'a>>, Box<Expression<'a>>),
    MethodCall(
        Box<Expression<'a>>,
        Option<TypeId>,
        Ident,
        Vec<Expression<'a>>,
    ),
    Object(Ident),
    IntLiteral(i32),
    StrLiteral(String),
    BoolLiteral(bool),
}

#[derive(Debug, PartialEq)]
pub enum UnaryOperator {
    Not,
    Negative,
    IsVoid,
}

#[derive(Debug, PartialEq)]
pub enum BinaryOperator {
    Equals,
    LessThanOrEquals,
    LessThan,
    Add,
    Subtract,
    Multiply,
    Divide,
}

impl<'a> ExpressionData<'a> {
    pub fn new_assign(ident: Ident, expression: Expression<'a>) -> Self {
        Assign(ident, Box::new(expression))
    }

    pub fn new_unary_operation(
        operator: &TokenKind,
        operand: Expression<'a>,
    ) -> Self {
        let oper = match operator {
            TokenKind::Not => UnaryOperator::Not,
            TokenKind::Negative => UnaryOperator::Negative,
            TokenKind::IsVoid => UnaryOperator::IsVoid,
            _ => panic!("Invalid unary operator"),
        };
        UnaryOperation(oper, Box::new(operand))
    }

    pub fn new_binary_operation(
        operand1: Expression<'a>,
        operator: &TokenKind,
        operand2: Expression<'a>,
    ) -> Self {
        let oper = match operator {
            TokenKind::Equals => BinaryOperator::Equals,
            TokenKind::LessThanOrEquals => BinaryOperator::LessThanOrEquals,
            TokenKind::LessThan => BinaryOperator::LessThan,
            TokenKind::Add => BinaryOperator::Add,
            TokenKind::Subtract => BinaryOperator::Subtract,
            TokenKind::Multiply => BinaryOperator::Multiply,
            TokenKind::Divide => BinaryOperator::Divide,
            _ => panic!("Invalid binary operator"),
        };
        BinaryOperation(oper, Box::new(operand1), Box::new(operand2))
    }

    pub fn new_method_call(
        expr: Expression<'a>,
        static_type: Option<TypeId>,
        ident: Ident,
        params: Vec<Expression<'a>>,
    ) -> Self {
        MethodCall(Box::new(expr), static_type, ident, params)
    }

    pub fn format(&self, indent: usize) -> ExpressionDataFormatter {
        ExpressionDataFormatter::new(self, indent)
    }
}
