//! Parse tree structures, which are directly generated by the parser
//! from Cool source code.

mod printer;

use self::printer::*;
use Expression::*;
use Feature::*;

pub type ObjectId = String;
pub type TypeId = String;

pub struct Program {
    classes: Vec<Class>,
}

impl Program {
    pub fn new(classes: Vec<Class>) -> Self {
        Self { classes }
    }

    pub fn print<'a>(&'a self, filename: &'a str) -> ProgramPrinter<'a> {
        ProgramPrinter::new(self, filename)
    }
}

#[derive(Debug, PartialEq)]
pub struct Class {
    pub name: TypeId,
    pub super_class_name: TypeId,
    pub features: Vec<Feature>,
}

impl Class {
    pub fn new(
        name: TypeId,
        super_class: Option<TypeId>,
        features: Vec<Feature>,
    ) -> Self {
        let super_class_name =
            super_class.unwrap_or_else(|| "Object".to_string());
        Self {
            name,
            super_class_name,
            features,
        }
    }

    pub fn print<'a>(
        &'a self,
        filename: &'a str,
        indent: usize,
    ) -> ClassPrinter<'a> {
        ClassPrinter::new(self, filename, indent)
    }
}

#[derive(Debug, PartialEq)]
pub enum Feature {
    Attribute(ObjectId, TypeId, Option<Expression>),
}

impl Feature {
    pub fn print(&self, indent: usize) -> FeaturePrinter {
        FeaturePrinter::new(self, indent)
    }
}

#[derive(Debug, PartialEq)]
pub enum Expression {
    Addition(Box<Expression>, Box<Expression>),
    Subtraction(Box<Expression>, Box<Expression>),
    Multiplication(Box<Expression>, Box<Expression>),
    Division(Box<Expression>, Box<Expression>),
    IntegerLiteral(String),
    StringLiteral(String),
    BooleanLiteral(String),
}

impl Expression {
    pub fn new_arith_expression(
        operand1: Expression,
        operator: char,
        operand2: Expression,
    ) -> Expression {
        let expr1 = Box::new(operand1);
        let expr2 = Box::new(operand2);
        match operator {
            '+' => Addition(expr1, expr2),
            '-' => Subtraction(expr1, expr2),
            '*' => Multiplication(expr1, expr2),
            '/' => Division(expr1, expr2),
            _ => panic!("Unknown operator"),
        }
    }
}
