//! Parse tree structures, which are directly generated by the parser
//! from Cool source code.

mod format;

use self::format::*;
use crate::tokens::{Ident, Span, TokenKind, TypeId};
use ExpressionData::*;

pub struct Program<'a> {
    pub classes: Vec<Class<'a>>,
}

impl<'a> Program<'a> {
    pub fn new(classes: Vec<Class<'a>>) -> Self {
        Self { classes }
    }

    pub fn format(&'a self) -> ProgramFormatter<'a> {
        ProgramFormatter::new(self)
    }
}

#[derive(Debug, PartialEq)]
pub struct Class<'a> {
    pub name: TypeId,
    pub super_class_name: TypeId,
    pub features: Vec<Feature<'a>>,
    pub location: Span<'a>,
}

impl<'a> Class<'a> {
    pub fn new(
        name: TypeId,
        super_class: Option<TypeId>,
        features: Vec<Feature<'a>>,
        location: Span<'a>,
    ) -> Self {
        let super_class_name =
            super_class.unwrap_or_else(|| "Object".to_string());
        Self {
            name,
            super_class_name,
            features,
            location,
        }
    }

    pub fn format(&'a self, indent: usize) -> ClassFormatter<'a> {
        ClassFormatter::new(self, indent)
    }
}

#[derive(Debug, PartialEq)]
pub struct Feature<'a> {
    pub data: FeatureData<'a>,
    pub location: Span<'a>,
}

impl<'a> Feature<'a> {
    pub fn new(data: FeatureData<'a>, location: Span<'a>) -> Self {
        Self { data, location }
    }

    pub fn format(&self, indent: usize) -> FeatureFormatter {
        FeatureFormatter::new(self, indent)
    }
}

#[derive(Debug, PartialEq)]
pub enum FeatureData<'a> {
    Attribute(Ident, TypeId, Option<Expression<'a>>),
    // Method(Ident, TypeId, Vec<Formals>, Option<Expression<'a>),
}

impl FeatureData<'_> {
    pub fn format(&self, indent: usize) -> FeatureDataFormatter {
        FeatureDataFormatter::new(self, indent)
    }
}

#[derive(Debug, PartialEq)]
pub struct Expression<'a> {
    pub data: ExpressionData<'a>,
    pub location: Span<'a>,
}

impl<'a> Expression<'a> {
    pub fn new(data: ExpressionData<'a>, location: Span<'a>) -> Self {
        Self { data, location }
    }

    pub fn format(&self, indent: usize) -> ExpressionFormatter {
        ExpressionFormatter::new(self, indent)
    }
}

#[derive(Debug, PartialEq)]
pub enum ExpressionData<'a> {
    ArithOperation(ArithOperator, Box<Expression<'a>>, Box<Expression<'a>>),
    CompOperation(CompOperator, Box<Expression<'a>>, Box<Expression<'a>>),
    IntLiteral(i32),
    StrLiteral(String),
    BoolLiteral(bool),
}

#[derive(Debug, PartialEq)]
pub enum CompOperator {
    Equals,
    LessThanOrEquals,
    LessThan,
}

#[derive(Debug, PartialEq)]
pub enum ArithOperator {
    Add,
    Subtract,
    Multiply,
    Divide,
}

impl<'a> ExpressionData<'a> {
    pub fn new_comp_operation(
        operand1: Expression<'a>,
        operator: &TokenKind,
        operand2: Expression<'a>,
    ) -> Self {
        let expr1 = Box::new(operand1);
        let expr2 = Box::new(operand2);
        let oper = match operator {
            TokenKind::Equals => CompOperator::Equals,
            TokenKind::LessThanOrEquals => CompOperator::LessThanOrEquals,
            TokenKind::LessThan => CompOperator::LessThan,
            _ => panic!("Invalid comparison operator"),
        };
        CompOperation(oper, expr1, expr2)
    }

    pub fn new_arith_operation(
        operand1: Expression<'a>,
        operator: &TokenKind,
        operand2: Expression<'a>,
    ) -> Self {
        let expr1 = Box::new(operand1);
        let expr2 = Box::new(operand2);
        let oper = match operator {
            TokenKind::Add => ArithOperator::Add,
            TokenKind::Subtract => ArithOperator::Subtract,
            TokenKind::Multiply => ArithOperator::Multiply,
            TokenKind::Divide => ArithOperator::Divide,
            _ => panic!("Invalid arithmetic operator"),
        };
        ArithOperation(oper, expr1, expr2)
    }

    pub fn format(&self, indent: usize) -> ExpressionDataFormatter {
        ExpressionDataFormatter::new(self, indent)
    }
}
