//! Parse tree structures, which are directly generated by the parser
//! from Cool source code.

mod printer;

use self::printer::*;
use Feature::*;

pub type ObjectId = String;
pub type TypeId = String;

pub struct Program {
    classes: Vec<Class>,
}

impl Program {
    pub fn new(classes: Vec<Class>) -> Self {
        Self { classes }
    }

    pub fn print<'a>(&'a self, filename: &'a str) -> ProgramPrinter<'a> {
        ProgramPrinter::new(self, filename)
    }
}

#[derive(Debug, PartialEq)]
pub struct Class {
    pub name: TypeId,
    pub super_class_name: TypeId,
    pub features: Vec<Feature>,
}

impl Class {
    pub fn new(
        name: TypeId,
        super_class: Option<TypeId>,
        features: Vec<Feature>,
    ) -> Self {
        let super_class_name = super_class.unwrap_or("Object".to_string());
        Self {
            name,
            super_class_name,
            features,
        }
    }

    pub fn print<'a>(
        &'a self,
        filename: &'a str,
        indent: usize,
    ) -> ClassPrinter<'a> {
        ClassPrinter::new(self, filename, indent)
    }
}

#[derive(Debug, PartialEq)]
pub enum Feature {
    Attribute(ObjectId, TypeId, Option<Expression>),
}

impl Feature {
    pub fn print(&self, indent: usize) -> FeaturePrinter {
        FeaturePrinter::new(self, indent)
    }
}

#[derive(Debug, PartialEq)]
pub enum Expression {
    StringLiteral(String),
    BooleanLiteral(String),
}
